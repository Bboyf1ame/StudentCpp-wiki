## Рассматриваемые темы: 
# Указатели

```c++ 
#pragma once

#include <iostream>

using namespace std;

namespace Pointers
{
   int main()
   ```
   
   
   
   
   >  *При использовании локальных переменных управление памятью берет на себя сама программа. 
      Когда завершится блок кода - локальная переменная будет вытолкнута из стека, 
      и таким образом ее память освободится.  
      Однако размер стека сильно ограничен. К тому же мы не имеем никакого управления над
      переменными внутри стека. А зачастую программисту требуется тонкий контроль над памятью.
      В этом случае используется динамическая область памяти - так называемая, куча (heap).
      Куча - это область памяти, управление которой полностью лежит на программисте,
      программа уже не имеет контроля над этой областью памяти.
      NB: данное высказывание работают не полностью в более высокоуровневых языка,
      таких как C# или Java, потому что ни работают в обертки собственной виртуальной машины и
      имеют ряд утилит для управления памятью кучи, например, "сборщик мусора".
      Для управления памятью в куче был введен тип данных - **УКАЗАТЕЛЬ**.
      Указатель - это переменная, которая хранит адрес ячейки памяти в куче.
      Объявляется указатель по следующему шаблону: 
      ТИП_ДАННЫХ* ИМЯ_ПЕРЕМЕННОЙ;
      NB: здесь тип_данных - это тип данных, которые хранятся по адресу в указателе.
      
      
      
   ```c++  
   int* ptr1;             - Это указатель
   float *ptr2;           - И это указатель
   double *ptr3;          - Это тоже указатель
   char* ptr4;            - И даже это указатель
   ```
   > *У всех этих переменных тип данных - указатель
     Не **int**, **float**, **double** или какой-то еще, а именно УКАЗАТЕЛЬ*

   ```c++
   int num1;              - Это переменная типа данных int
   int* anotherPtr1;      - А это указатель!
   float num2;            - Не указатель
   double num3;           - Тоже не указатель
   char *num4;            - А вот это указатель
   ```
   
   
   
  > *NB: синтаксически компилятор позволяет объвлять указатель двумя способами:*
      
   ```c++
   int* ptr5;
   ```
  >  *или*
  
   ```c++  
   int *ptr6; 
   ```
  > *По нотации С++ правильно писать именно так^^^*
  ____________________________________________________________
  
  > *Синтаксически разработчики компилятора сделали вот такую подлянку:*
   ```c++   
   int* a1, a2;
   ```
  > *Думаете здесь через запятую объявлено 2 переменных типа данных указатель?*
  > *А вот ФИГ ВАМ!
     В случае выше объявлен ОДИН указатель и ОДНА переменная int
     Чтобы через запятую получить два указателя, нужно писать так:*
   ```c++  
    int* a3, *a4; 
   ```
  > *Т.е. обязательно добавлять звездочку перед именем самой переменной. Без этого оператор запятая не сможет правильно разобрать конструкцию.*

> И вот из-за такой маленькой особенности, чтобы не забывать об этой синтаксической особенности
  исторически стали пристыковыввать звездочку к имени переменной. Вот так:
  
  ```c++
  int *a6;
  ```
> Но у многих начинающих С++ программистов из-за этого начинаются проблемы 
  с идентификацией типа данных переменных
  
  ```c++
  int *some_variable;
  ```
>  На вопрос "Какой это тип данных?"
  Часто дают ответ - "int естественно". Видимо символ * - это мухи натоптали на экране.
  Поэтому некоторые, чтобы не забывать об этом, стыкуют звездочку именно с типом данных
  
  ```c++
  int* another_variable;
  ```
 > Лично мне нравится писать именно так^^^. Никто вас за это не осудит, но по стандарту делается это наоборот.
 
 
 
 > Кстати, а сколько памяти занимается указатель в памяти? Это же переменная и, значит, под нее выделяется память.
   Есть отличная команда sizeof, которая может получить размер переменной или типа данных
      
