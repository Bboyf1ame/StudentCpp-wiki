## Рассматриваемые темы: 
# Указатели

```c++ 
#pragma once

#include <iostream>

using namespace std;

namespace Pointers
{
   int main()
   ```
   
   >  *При использовании локальных переменных управление памятью берет на себя сама программа. 
      Когда завершится блок кода - локальная переменная будет вытолкнута из стека, 
      и таким образом ее память освободится.  
      Однако размер стека сильно ограничен. К тому же мы не имеем никакого управления над
      переменными внутри стека. А зачастую программисту требуется тонкий контроль над памятью.
      В этом случае используется динамическая область памяти - так называемая, куча (heap).
      Куча - это область памяти, управление которой полностью лежит на программисте,
      программа уже не имеет контроля над этой областью памяти.
      NB: данное высказывание работают не полностью в более высокоуровневых языка,
      таких как C# или Java, потому что ни работают в обертки собственной виртуальной машины и
      имеют ряд утилит для управления памятью кучи, например, "сборщик мусора".
      Для управления памятью в куче был введен тип данных - **УКАЗАТЕЛЬ**.
      Указатель - это переменная, которая хранит адрес ячейки памяти в куче.
      Объявляется указатель по следующему шаблону: 
      ТИП_ДАННЫХ* ИМЯ_ПЕРЕМЕННОЙ;
      NB: здесь тип_данных - это тип данных, которые хранятся по адресу в указателе.

   ```c++  
   int* ptr1;             - Это указатель
   float *ptr2;           - И это указатель
   double *ptr3;          - Это тоже указатель
   char* ptr4;            - И даже это указатель
   ```
   > *У всех этих переменных тип данных - указатель
     Не **int**, **float**, **double** или какой-то еще, а именно УКАЗАТЕЛЬ*

   ```c++
   int num1;              - Это переменная типа данных int
   int* anotherPtr1;      - А это указатель!
   float num2;            - Не указатель
   double num3;           - Тоже не указатель
   char *num4;            - А вот это указатель
   ```

  > *NB: синтаксически компилятор позволяет объвлять указатель двумя способами:*
      
   ```c++
   int* ptr5;
   ```
  >  *или*
  
   ```c++  
   int *ptr6; 
   ```
  > *По нотации С++ правильно писать именно так^^^*
  ____________________________________________________________
  
  > *Синтаксически разработчики компилятора сделали вот такую подлянку:*
   ```c++   
   int* a1, a2;
   ```
  > *Думаете здесь через запятую объявлено 2 переменных типа данных указатель?*
  > *А вот ФИГ ВАМ!
     В случае выше объявлен ОДИН указатель и ОДНА переменная int
     Чтобы через запятую получить два указателя, нужно писать так:*
   ```c++  
    int* a3, *a4; 
   ```
  > *Т.е. обязательно добавлять звездочку перед именем самой переменной. Без этого оператор запятая не сможет правильно разобрать конструкцию.*

> *И вот из-за такой маленькой особенности, чтобы не забывать об этой синтаксической особенности
  исторически стали пристыковыввать звездочку к имени переменной. Вот так:*
  
  ```c++
  int *a6;
  ```
> *Но у многих начинающих С++ программистов из-за этого начинаются проблемы 
  с идентификацией типа данных переменных*
  
  ```c++
  int *some_variable;
  ```
>  *На вопрос "Какой это тип данных?"
  Часто дают ответ - "int естественно". Видимо символ * - это мухи натоптали на экране.
  Поэтому некоторые, чтобы не забывать об этом, стыкуют звездочку именно с типом данных*
  
  ```c++
  int* another_variable;
  ```
 > *Лично мне нравится писать именно так^^^. Никто вас за это не осудит, но по стандарту делается это наоборот.*
 > *Кстати, а сколько памяти занимается указатель в памяти? Это же переменная и, значит, под нее выделяется память.
   Есть отличная команда sizeof, которая может получить размер переменной или типа данных*
      
  ```c++
  cout << "sizeof(short) = " << sizeof(short) << endl
         << "sizeof(int) = " << sizeof(int) << endl      
         << "sizeof(long long) = " << sizeof(long long) << endl  
         << "sizeof(char) = " << sizeof(char) << endl      
         << "sizeof(int*) = " << sizeof(int) << endl        
         << "sizeof(double*) = " << sizeof(double*) << endl 
         << "sizeof(char*) = " << sizeof(char*) << endl;    
   ```
   
  > *Запустите и проверьте, что вывдетеся на экран.
    Такой маленький эксперимент показывает, что вне зависимости от тип данных, адрес которых хранит указатель,
    размер самого указателя    не меняется.
    И это логично. Указатель - это просто адрес. А размерность шины адреса
    в вычислительной машине - фиксирована.*

  > *Если указатель - это адрес, то как сохранить адрес в указатель? 
    Сам же он там не появится, мы должны этот адрес как-то узнать,
    а затем сохранить в указатель.
    Для работы с указателями есть 2 оператора:
    1. operator& - получить адрес переменной. Например,*
   ```c++
    int a = 5;
    int* ptr_a = &a; 
   ```
  > *В ptr_a сохранится адрес ячейки памяти, в которой хранится переменная a.*
    *2. operator** *- получить данные из ячейки памяти по ее адресу.*
   ```c++
    int b = *ptr_a;
   ```
  > *В ptr_a хранится адрес ячейки памяти, в которой хранится число 5.
    С помощью оператора звездочка мы по адресу из указатель ptr_a получаем*
    данные. В данном случае это число 5.
