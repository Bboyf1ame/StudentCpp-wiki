## Рассматриваемые темы: 
# Указатели

```c++ 
#pragma once

#include <iostream>

using namespace std;

namespace Pointers
{
   int main()
   ```
   
   >  *При использовании локальных переменных управление памятью берет на себя сама программа. 
      Когда завершится блок кода - локальная переменная будет вытолкнута из стека, 
      и таким образом ее память освободится.  
      Однако размер стека сильно ограничен. К тому же мы не имеем никакого управления над
      переменными внутри стека. А зачастую программисту требуется тонкий контроль над памятью.
      В этом случае используется динамическая область памяти - так называемая, куча (heap).
      Куча - это область памяти, управление которой полностью лежит на программисте,
      программа уже не имеет контроля над этой областью памяти.
      NB: данное высказывание работают не полностью в более высокоуровневых языка,
      таких как C# или Java, потому что ни работают в обертки собственной виртуальной машины и
      имеют ряд утилит для управления памятью кучи, например, "сборщик мусора".
      Для управления памятью в куче был введен тип данных - **УКАЗАТЕЛЬ**.
      Указатель - это переменная, которая хранит адрес ячейки памяти в куче.
      Объявляется указатель по следующему шаблону: 
      ТИП_ДАННЫХ* ИМЯ_ПЕРЕМЕННОЙ;
      NB: здесь тип_данных - это тип данных, которые хранятся по адресу в указателе.
\u0013
   ```c++  
   int* ptr1;             - Это указатель
   float *ptr2;           - И это указатель
   double *ptr3;          - Это тоже указатель
   char* ptr4;            - И даже это указатель
   ```
   > *У всех этих переменных тип данных - указатель
     Не **int**, **float**, **double** или какой-то еще, а именно УКАЗАТЕЛЬ*

   ```c++
   int num1;              - Это переменная типа данных int
   int* anotherPtr1;      - А это указатель!
   float num2;            - Не указатель
   double num3;           - Тоже не указатель
   char *num4;            - А вот это указатель
   ```

  > *NB: синтаксически компилятор позволяет объвлять указатель двумя способами:*
      
   ```c++
   int* ptr5;
   ```
  >  *или*
  
   ```c++  
   int *ptr6; 
   ```
  > *По нотации С++ правильно писать именно так^^^*
  ____________________________________________________________
  
  > *Синтаксически разработчики компилятора сделали вот такую подлянку:*
   ```c++   
   int* a1, a2;
   ```
  > *Думаете здесь через запятую объявлено 2 переменных типа данных указатель?*
  > *А вот ФИГ ВАМ!
     В случае выше объявлен ОДИН указатель и ОДНА переменная int
     Чтобы через запятую получить два указателя, нужно писать так:*
   ```c++  
    int* a3, *a4; 
   ```
  > *Т.е. обязательно добавлять звездочку перед именем самой переменной. Без этого оператор запятая не сможет правильно разобрать конструкцию.*

> *И вот из-за такой маленькой особенности, чтобы не забывать об этой синтаксической особенности
  исторически стали пристыковыввать звездочку к имени переменной. Вот так:*
  
  ```c++
  int *a6;
  ```
> *Но у многих начинающих С++ программистов из-за этого начинаются проблемы 
  с идентификацией типа данных переменных*
  
  ```c++
  int *some_variable;
  ```
>  *На вопрос "Какой это тип данных?"
  Часто дают ответ - "int естественно". Видимо символ * - это мухи натоптали на экране.
  Поэтому некоторые, чтобы не забывать об этом, стыкуют звездочку именно с типом данных*
  
  ```c++
  int* another_variable;
  ```
 > *Лично мне нравится писать именно так^^^. Никто вас за это не осудит, но по стандарту делается это наоборот.*
 > *Кстати, а сколько памяти занимается указатель в памяти? Это же переменная и, значит, под нее выделяется память.
   Есть отличная команда sizeof, которая может получить размер переменной или типа данных*
      
  ```c++
  cout << "sizeof(short) = " << sizeof(short) << endl
         << "sizeof(int) = " << sizeof(int) << endl      
         << "sizeof(long long) = " << sizeof(long long) << endl  
         << "sizeof(char) = " << sizeof(char) << endl      
         << "sizeof(int*) = " << sizeof(int) << endl        
         << "sizeof(double*) = " << sizeof(double*) << endl 
         << "sizeof(char*) = " << sizeof(char*) << endl;    
   ```
   
  > *Запустите и проверьте, что вывдетеся на экран.
    Такой маленький эксперимент показывает, что вне зависимости от тип данных, адрес которых хранит указатель,
    размер самого указателя    не меняется.
    И это логично. Указатель - это просто адрес. А размерность шины адреса
    в вычислительной машине - фиксирована.*

  > *Если указатель - это адрес, то как сохранить адрес в указатель? 
    Сам же он там не появится, мы должны этот адрес как-то узнать,
    а затем сохранить в указатель.
    Для работы с указателями есть 2 оператора:
    1. operator& - получить адрес переменной. Например,*
   ```c++
    int a = 5;
    int* ptr_a = &a; 
   ```
  > *В ptr_a сохранится адрес ячейки памяти, в которой хранится переменная a.*
    *2. operator** *- получить данные из ячейки памяти по ее адресу.*
   ```c++
    int b = *ptr_a;
   ```
  > *В ptr_a хранится адрес ячейки памяти, в которой хранится число 5.
    С помощью оператора звездочка мы по адресу из указатель ptr_a получаем
    данные. В данном случае это число 5.*

 ## ТЕКСТ, КОТОРЫЙ НУЖНО ВНИМАТЕЛЬНО ОСОЗНАТЬ
 ###  int* ptr;
 ###  cout << *ptr;
 ###  В двух этих строчках звездочки - это РАЗНЫЕ вещи.
 ###  int* - здесь звездочка это синтаксическое обозначение типа данных указателя.
 ###  *ptr - здесь звездочка это оператор. Оператор всегда что-то делает.
 ###  У оператора есть над чем идет операция и оператор зачастую что-то возвращает как результат.
 ### А звездочка в синтаксисе объявления типа данных - ничего не делает. Запомните и осознайте это!
 
   >  *И все же, что действительно скрывается за конструкцией  ТИП_ДАННЫХ* ИМЯ_ПЕРЕМЕННОЙ;
     Допустим, у нас есть переменная*
  
  ``` c++
    long long number = 65796;
      и указатель
    long long* ptr = &number;
  ```
  
  > *Тогда связь этих переменных в памяти будет такой:
   
   ![Документ1](https://vk.com/doc475362914_464562442)
        
        
            0xFFFC2, ptr              0xFFF01, number
           |-----------|               |---------|
           |  0xFFF01  |               |  65796  |
           |-----------|               |---------|
           
           
   > *Разберем, что на картинке.
     Сверху написаны адрес ячейки памяти и имя переменной этой ячейки.
     (Помните же, что переменная - это просто символьное имя ячейки памяти
     в помощь программисту)
     0xFFF01 - это адрес ячейки переменной number, которая хранит число 65796
     0xFFFC2 - это адрес ячейки переменной ptr, которая хранит число адр2 - адрес другой ячейки
     Только имейте в виде, что 0xFFF01 и 0xFFF01 - число только для примера. На самом деле
     после каждого запуска программы на разных машинах эти адреса будут меняться.
     Неизвестно в каком участке памяти развернется ваша программа, и какое адресное пространство
     будет ей предоставлено.*
     
 ```c++
   cout << "адр2 = " << ptr << endl;
 ```
   > *Почему я не могу записать адреса явным числом? Потому что после каждого запуска программы
     эти адреса буду меняться.
     Но на самом деле даже эта визуализация упрощенная, потому что минимальная адресуемая 
     ячейка памяти - 1 байт. Но указатель занимает 4 байта, а переменная long long занимает 8 байт
     А у нас на рисунке только одна ячейка, хотя должно быть 4 и 8 соответственно. 
     Давайте для простоты ptr так и будем в упрощенном виде обозначать одной ячейкой,
     а вот number нарисуем, как оно действительно выглядит в памяти.
     Как разместить такое простенькое число 65796 аж в 8 ячейках памяти?
     Машина все числа хранит в двочином виде. В бинарном представлении число 65796 выглядит так:
       ТАБЛИЦА БАЙТОВ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     Это 8 байт. 1 байт = 8 бит. И у нас записано 8 раза по 8 бит. 
     Т.к. первые нули - незначащие, то число всегда можно расширить до нужного размера.    
     Для удобства значение каждого отдельного байта переведено в десятиричную СС.
     Правило хранения чисел в памяти гласит:
     Старший барт лежит по старшему адресу.
     Наше число number лежит (точнее только начинается) по адресу 0xFFF01
       ТАБЛИЦА ПОСЛЕ БАЙТОВ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     Ну ок. И причем тут указатели и вся эта абра-кадабра?*

